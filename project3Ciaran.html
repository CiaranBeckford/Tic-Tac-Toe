<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link href="grid12.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">
<title> Project </title>
<script type="text/javascript">

  var numGrid = 3;

  //a 2D array of cells (elements)
  var board = new Array(numGrid);
  for(var i=0; i<numGrid; i++)
    board[i] = new Array(numGrid);

  
  //helper for AI2. A 2D array, each element contains the number of empty routes that grid is on.
  var map = new Array(numGrid);
  for(var i=0; i<numGrid; i++)
    map[i] = new Array(numGrid);
  /*
  helper for AI3. A 2D array of coordinates, 
  whose r is identical to map and c records the number of routes that now only has opponent on it.
  */
  var map2 = new Array(numGrid);
  for(var i=0; i<numGrid; i++)
    map2[i] = new Array(numGrid);

  var max = 0;//largest number in map
  var maxArray = new Array();//array of grids that has the largest number in map

  var gameOver = false;
  var winner;

  var player1 = new Player('User','X');
  var player2 = new Player('AI3','O');
  player1.opponent = player2;
  player2.opponent = player1;

  var startingPlayer = player1;
  var currentPlayer;

  //start!
  function startGame() {
    currentPlayer = startingPlayer;
    currentPlayer.move();
  }

  
  function Player(name, letter) {
    this.name = name;
    this.letter = letter;
    this.opponent;

    if(name == 'random') this.move = function(){computerMove(randomCoord);};
    else if(name == 'AI0') this.move = function(){computerMove(AI0);};
    else if(name == 'AI1') this.move = function(){computerMove(AI1);};
    else if(name == 'AI2') this.move = function(){computerMove(AI2);};
    else if(name == 'AI3') this.move = function(){computerMove(AI3);};
    else
    {
      this.move = function() {
        //get ready for user's move by making grids clickable and wait for user's click
        for(var i=0; i<numGrid; i++) {
          for(var j=0; j<numGrid; j++) 
            board[i][j].setAttribute('onClick','placeLetter(this)');
        }
      }
    }
  }

  
  function computerMove(algorithm) {
    //make grids unclickable. 
    for(var i=0; i<numGrid; i++) {
      for(var j=0; j<numGrid; j++) {
        board[i][j].setAttribute('onClick','');
      }
    }
    //This while loop simulates a click.
    var coord = algorithm();
    if(board[coord.r][coord.c].innerHTML != '') console.log('error: placed at somewhere occupied');
    setTimeout(function(){
      placeLetter(board[coord.r][coord.c]);
    },600);
  }

  //generates a random move (returns a Coordinate)
  function randomCoord() {
    while(true) {
      var r = Math.floor(Math.random()*numGrid);
      var c = Math.floor(Math.random()*numGrid);
      if(board[r][c].innerHTML == '') return new Coordinate(r,c);
    }
  }

  /*
  Attempt not to lose.
  If there's somewhere only one step away from winning, or one step from losing, it makes a move there.
  */
  function AI0() 
  {
    var Xhori=0; var Ohori=0;
    var Xvert=0; var Overt=0;
    var Xdiag1=0; var Odiag1=0;
    var Xdiag2=0; var Odiag2=0;
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Xs and Os
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      else if(board[i][i].innerHTML == currentPlayer.opponent.letter) Odiag1++;
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;

      //Last loop, should've counted all XOdiags. any diagonal almost-win/lose?
      if(i==numGrid-1 && (Xdiag1 == numGrid-1 || Odiag1 == numGrid-1) && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && (Xdiag2 == numGrid-1 || Odiag2 == numGrid-1) && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
          else if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
          else if(board[j][i].innerHTML == currentPlayer.opponent.letter) Overt++;
          
          //Last inner loop. Check for vertical almost-win/lose.
          if(j==numGrid-1 && (Xvert == numGrid-1 || Overt == numGrid-1) && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win/lose.
        if((Xhori == numGrid-1 || Ohori == numGrid-1) && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
      }
    }
    return randomCoord();
  }


  /*
  Similar to notSoRandom, 
  except it prefers filling the last blank to win over preventing its opponent from winning.
  */
  function AI1() 
  {
    var coord = emergency();
    if(coord != false) return coord;
    return randomCoord();
  }

  //Core of AI1.
  function emergency()
  {
    var Xhori=0; var Ohori=0;
    var Xvert=0; var Overt=0;
    var Xdiag1=0; var Odiag1=0;
    var Xdiag2=0; var Odiag2=0;

    //first time looping: win if it can
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Xs
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      //Last loop, should've counted all XOdiags. any diagonal almost-win?
      if(i==numGrid-1 && Xdiag1 == numGrid-1 && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && Xdiag2 == numGrid-1 && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
          //Last inner loop. Check for vertical almost-win.
          if(j==numGrid-1 && Xvert == numGrid-1 && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win.
        if(Xhori == numGrid-1 && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Xhori = 0; Xvert = 0;
      }
    }

    //second time looping- if it's only one step from losing, make sure that doesn't happen.
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Os
      if(board[i][i].innerHTML == currentPlayer.opponent.letter)Odiag1++;
      if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;
      //Last loop, should've counted all XOdiags. any diagonal almost-win?
      if(i==numGrid-1 && Odiag1 == numGrid-1 && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && Odiag2 == numGrid-1 && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.opponent.letter) Overt++;
          
          //Last inner loop. Check for vertical almost-win.
          if(j==numGrid-1 && Overt == numGrid-1 && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win.
        if(Ohori == numGrid-1 && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Ohori = 0; Overt = 0;
      }
    }
    return false;
  }

  /*
  First detect any emergency (one step from win or lose). If there is one, make that move.
  If no emergency and there's any move better than pure random, make that move: 
    The spot that is on the most number of all-blank horizontal/vertical/diagonal lines
    If there're multiple such moves, pick a random one among them.
  */
  function AI2() 
  {
    updateMap();
    var alternate = getAlternateMove();
    var priority = emergency();
    if(priority != false) return priority;
    return alternate;
  }

  function AI3() 
  {
    updateMap_v2();
    var alternate = getAlternateMove_v2();
    var priority = emergency();
    if(priority != false) return priority;
    return alternate;
  }
  
  //Core of AI2
  function getAlternateMove()
  {
    max = 0;
    maxArray = new Array();
    for(var i=0; i<numGrid; i++)
    {
      for(var j=0; j<numGrid; j++)//access each grid
      {
        if(board[i][j].innerHTML == '')//count only blank grids
        {
          if(map[i][j] > max) 
          {
            max = map[i][j];
            maxArray = new Array();
            maxArray[maxArray.length] = new Coordinate(i,j);
          } else if(map[i][j] == max) 
            maxArray[maxArray.length] = new Coordinate(i,j);
        }
      }
    }
    if(maxArray.length == 0) {
      return randomCoord();
      console.log('calling randomCoord from getAlternateMove (shouldn\'t happen)');
    }
    var rand = Math.floor(Math.random()*maxArray.length);
    return maxArray[rand];
  }

  var newMax;
  var newMaxArray;
  //core of AI3
  function getAlternateMove_v2()
  {
    max = 0;
    maxArray = new Array();//array of coordinates. R contains a coordinate to be returned, c contains c in map2
    for(var i=0; i<numGrid; i++)
    {
      for(var j=0; j<numGrid; j++)//access each grid
      {
        if(board[i][j].innerHTML == '')//count only blank grids
        {
          if(map2[i][j].r > max) 
          {
            max = map2[i][j].r;
            maxArray = new Array();
            maxArray[maxArray.length] = new Coordinate(new Coordinate(i,j),map2[i][j].c);
          } else if(map2[i][j].r == max) 
            maxArray[maxArray.length] = new Coordinate(new Coordinate(i,j),map2[i][j].c);
        }
      }
    }
    if(maxArray.length == 0) {
      return randomCoord();
      console.log('calling randomCoord from getAlternateMove (shouldn\'t happen)');
    }
    newMax = 0;
    newMaxArray = new Array();
    for(var i=0; i<maxArray.length; i++)
    {
      if(maxArray[i].c > newMax)
      {
        newMax = maxArray[i].c;
        newMaxArray = new Array();
        newMaxArray[newMaxArray.length] = maxArray[i].r;
      } else if (maxArray[i].c == newMax) 
        newMaxArray[newMaxArray.length] = maxArray[i].r;
    }

    var rand = Math.floor(Math.random()*newMaxArray.length);
    return newMaxArray[rand];
  }
  
  function updateMap() {
    for(var i=0; i<numGrid; i++)
    {
      for(var j=0; j<numGrid; j++) map[i][j] = 0;
    }

    for(var i=0; i<numGrid; i++)//each row
    {
      for(var j=0; j<numGrid; j++)//each grid
      {
        if(board[i][j].innerHTML == '')//each blank grid
        {
          var h = 0; var v = 0;
          for(var k=0; k<numGrid; k++)//h and v
          {
            if(board[k][j].innerHTML == '') h++;//each grid that shares i with this blank
            if(board[i][k].innerHTML == '') v++;//each grid that shares j with this blank
          }
          if (h == numGrid) map[i][j]++;
          if (v == numGrid) map[i][j]++;

          var v1 = 0; 
          if(i == j)//on v1
          {
            for (var k=0; k<numGrid; k++)//each grid on v1
            {
              if(board[k][k].innerHTML == '') v1++;
            }
          }
          if(v1 == numGrid) map[i][j]++;

          var v2 = 0;
          if(i == numGrid-j-1)//on v2
          {
            for (var k=0; k<numGrid; k++)//each grid on v2
            {
              if(board[k][numGrid-k-1].innerHTML == '')v2++;
            }
          }
          if(v2 == numGrid) map[i][j]++;
        }
      }
    }
  }

  function updateMap_v2() {
    for(var i=0; i<numGrid; i++)
    {
      //r contains #blanks it is on, c contains #only-opponent routes it is on.
      for(var j=0; j<numGrid; j++) map2[i][j] = new Coordinate(0,0);
    }

    for(var i=0; i<numGrid; i++)//each row
    {
      for(var j=0; j<numGrid; j++)//each grid
      {
        if(board[i][j].innerHTML == '')//each blank grid
        {
          var h = 0; var v = 0; //#blanks on the same row/column with this
          var ho = false; var vo = false;//whether there's opponent on the same row/column
          var hx = false; var vx = false;//whether it's already safe
          for(var k=0; k<numGrid; k++)//h and v
          {
            if(board[k][j].innerHTML == '') h++;//each grid that shares i with this blank
            else if(board[k][j].innerHTML == currentPlayer.opponent.letter) ho = true;
            else hx = true;
            if(board[i][k].innerHTML == '') v++;//each grid that shares j with this blank
            else if(board[i][k].innerHTML == currentPlayer.opponent.letter) ho = true;
            else vx = true;
          }
          if (h == numGrid) map2[i][j].r++;
          if (v == numGrid) map2[i][j].r++;
          if (ho && !hx) map2[i][j].c++;
          if (vo && !vx) map2[i][j].c++;

          var v1 = 0; var v1o = false; var v1x = false;
          if(i == j)//on v1
          {
            for (var k=0; k<numGrid; k++)//each grid on v1
            {
              if(board[k][k].innerHTML == '') v1++;
              else if(board[k][k].innerHTML == currentPlayer.opponent.letter) v1o = true;
              else v1x = true;
            }
          }
          if(v1 == numGrid) map2[i][j].r++;
          if(v1o && !v1x) map2[i][j].c++;

          var v2 = 0; var v2o = false; var v2x = false;
          if(i == numGrid-j-1)//on v2
          {
            for (var k=0; k<numGrid; k++)//each grid on v2
            {
              if(board[k][numGrid-k-1].innerHTML == '')v2++;
              else if(board[k][numGrid-k-1].innerHTML == currentPlayer.opponent.letter) v2o = true;
              else v2x = true;
            }
          }
          if(v2 == numGrid) map2[i][j].r++;
          if(v2o && !v2x) map2[i][j].c++;
        }
      }
    }
  }

  //If there's an only empty Coordinate in a certain row/column/diagonal, return it.
  function AIhelper(direction, num) {
    if(direction == 'diag1') {
      //top left to bottom right
      for (var i=0; i<numGrid; i++) 
        if(board[i][i].innerHTML == '') return new Coordinate(i,i);
    } else if (direction == 'diag2') {
      //top right to bottom left
      for (var i=0; i<numGrid; i++) 
        if(board[i][numGrid-i-1].innerHTML == '') {
          return new Coordinate(i,numGrid-i-1);}
    } else if (direction == 'hori') {
      //num, ?
      for (var i=0; i<numGrid; i++) 
        if(board[num][i].innerHTML == '') return new Coordinate(num,i);
    } else if (direction == 'vert') {
      //?, num
      for (var i=0; i<numGrid; i++)
        if(board[i][num].innerHTML == '') return new Coordinate(i,num);
    }
    return false;
  }
  
  function Coordinate(r, c) {
    this.r = r;
    this.c = c;
  }

  /*
  Evenly divides #container into numGrid rows and numGrid columns of cells
  And store them into board for later access
  */
	function generateCells()
  {
    var container = document.getElementById('container');
    var proportion = 100/numGrid;//percentage of width or height per cell

    for(var i=0; i<numGrid; i++) {
      //create and add row
      var row = document.createElement('div');
      row.style.height = proportion + '%';
      row.className = 'row';
      container.appendChild(row);
      for(var j=0; j<numGrid; j++) {
        //create and add cell
        var cell = document.createElement('div');
        cell.classList.add('cell');
        if(j == 0) cell.classList.add('left');
        if(j == numGrid-1) cell.classList.add('right');
        if(i == 0) cell.classList.add('top');
        if(i == numGrid-1) cell.classList.add('bottom');
        cell.style.position = 'relative';
        cell.style.float = 'left';
        cell.style.width = proportion + '%';
        row.appendChild(cell);
        //add this cell to board (2D array)
        board[i][j] = cell;
      }
    }
  }

  function placeLetter(element) {
    if(gameOver || element.innerHTML != '') return;
    if(currentPlayer == startingPlayer)
      element.classList.add('X');
    else
      element.classList.add('O');
    element.style.lineHeight = container.clientHeight/numGrid + 'px';
    element.innerHTML = currentPlayer.letter;

    winner = detectWin();
    if(gameOver) {
      //end the game
      var msg = document.getElementById('winner-message')
      if(winner == 'draw')
        msg.innerHTML = 'Draw!'
      else if(winner == player1)
        msg.innerHTML = player1.name + ' ' + msg.innerHTML;
      else
        msg.innerHTML = player2.name + ' ' + msg.innerHTML;
      msg.hidden = false;
      //make grids unclickable. 
      for(var i=0; i<numGrid; i++) {
        for(var j=0; j<numGrid; j++) {
          board[i][j].setAttribute('onClick','');
        }
      }
    } else {
      //change player
      currentPlayer = currentPlayer.opponent;
      currentPlayer.move();
    }
  }

  /*
  return 'X' if X wins, or return 'O' if O wins. 
  return 'draw' if the whole board is filled but nobody wins.
  Otherwise doesn't change or return anything.
  */
  var deadCount = 0;
  function detectWin() 
  {
    deadCount = 0;//if a straight line contains both X and O, it's dead. No possible win there.
    var Xhori = 0; var Ohori = 0;
    var Xvert = 0; var Overt = 0;
    var Xdiag1 = 0; var Odiag1 = 0;
    var Xdiag2 = 0; var Odiag2 = 0;
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal 1 every loop
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      else if(board[i][i].innerHTML == currentPlayer.opponent.letter)Odiag1++;
      //count diagonal 2 every loop
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;
      if(i == numGrid-1)//last outer loop
      {
        //any diagonal win, after going through this outer loop check?
        if(Xdiag1 == numGrid || Xdiag2 == numGrid) {gameOver = true; return currentPlayer.letter;}
        else if(Odiag1 == numGrid || Odiag2 == numGrid) {gameOver = true; return currentPlayer.opponent.letter;}
        //are the two diagonals dead by now?
        if(Xdiag1>0 && Odiag1>0) deadCount++;
        if(Xdiag2>0 && Odiag2>0) deadCount++;
      }

      //no? check for horizontal and vertical.
      for (var j=0; j<numGrid; j++) 
      {
        //horizontal
        if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
        else if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
        //vertical
        if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
        else if(board[j][i].innerHTML == currentPlayer.opponent.letter)Overt++;
      }
      //any horizantal or vertical win, after running this inner loop?
      if(Xhori == numGrid || Xvert == numGrid) {gameOver = true; return currentPlayer;}
      else if(Ohori == numGrid || Overt == numGrid) {gameOver = true; return currentPlayer.opponent;}
      //check horizontal/vertical deads
      if(Xhori>0 && Ohori>0) deadCount++;
      if(Xvert>0 && Overt>0) deadCount++;
      //reset horizontal and vertical count variables
      Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
    }
    if(deadCount == 2 * numGrid + 2) {gameOver = true; return 'draw';}
  }

</script>
<style>
  *{
    margin:0;
    padding:0;
    font-family: 'Architects Daughter', cursive;
    color:#706764;
  }

  p{
    font-size:22pt;
  }

  div.cell{
    margin:0;
    padding:0;
    height:100%;
    border:1px dashed #93958B;
  }

  div.left{
    border-left:none;
  }

  div.right{
    border-right:none;
  }

  div.top{
    border-top:none;
  }

  div.bottom{
    border-bottom:none;
  }

  div.cell:hover{
    background-color: #ffffcc;
  }

  .X,.O{
    width:100%;
    height:100%;
    font-size:54px;
    text-align:center;
    vertical-align:middle;
  }

  .X{
    color:#D47A61;
  }

  .O{
    color:#699E82;
  }
  #container{
    width:300px;
    height:300px;
  }
  .title{
    margin:0.8em;
    text-align:center;
  }

</style>
</head>
<body onload="generateCells(); startGame();">
  <div class="container">
    <h1 class="title">Tic Tac Toe</h1>
    <div id="container" class="container-fluid"></div>
    <p class="title" id="winner-message" hidden>wins!</p>
  </div>
</body>
</html>