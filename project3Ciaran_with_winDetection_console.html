<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link href="grid12.css" rel="stylesheet">
<title> Project </title>
<script type="text/javascript">

  var numGrid = 4;

  //a 2D array of cells (elements)
  var board = new Array(numGrid);
  for(var i=0; i<numGrid; i++)
    board[i] = new Array(numGrid);

  
  //helper for AI2. A 2D array that contains the number of empty routes each grid is on.
  var map = new Array(numGrid);
  for(var i=0; i<numGrid; i++)
    map[i] = new Array(numGrid);

  var max = 0;//largest number in map
  var maxArray = new Array();//array of grids that has the largest number in map

  var gameOver = false;
  var winner;

  var player1 = new User();
  var player2 = new Computer(AI2);
  player1.opponent = player2;
  player2.opponent = player1;

  var currentPlayer = player1;

  //start!
  function startGame() {
    currentPlayer.letter = 'X';
    currentPlayer.opponent.letter = 'O';
    currentPlayer.move();
  }
  
  function User() {
    this.letter;
    this.opponent;
    this.move = function() {
      //get ready for user's move by making grids clickable and wait for user's click
      for(var i=0; i<numGrid; i++) {
        for(var j=0; j<numGrid; j++) 
          board[i][j].setAttribute('onClick','placeLetter(this)');
      }
    }
  }

  function Computer(algorithm) {
    this.letter;
    this.opponent;
    this.move = function() {
      //make grids unclickable. 
      for(var i=0; i<numGrid; i++) {
        for(var j=0; j<numGrid; j++) {
          board[i][j].setAttribute('onClick','');
        }
      }
      //This while loop simulates a click.
      var coord = algorithm();
      if(board[coord.r][coord.c].innerHTML != '') console.log('error: placed at somewhere occupied');
      setTimeout(function(){
        placeLetter(board[coord.r][coord.c]);
      },1000);
    }
  }

  //generates a random move (returns a Coordinate)
  function randomCoord() {
    while(true) {
      var r = Math.floor(Math.random()*numGrid);
      var c = Math.floor(Math.random()*numGrid);
      if(board[r][c].innerHTML == '') return new Coordinate(r,c);
    }
  }

  /*
  Attempt not to lose.
  If there's somewhere only one step away from winning, or one step from losing, it makes a move there.
  */
  function AI0() 
  {
    var Xhori=0; var Ohori=0;
    var Xvert=0; var Overt=0;
    var Xdiag1=0; var Odiag1=0;
    var Xdiag2=0; var Odiag2=0;
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Xs and Os
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      else if(board[i][i].innerHTML == currentPlayer.opponent.letter) Odiag1++;
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;

      //Last loop, should've counted all XOdiags. any diagonal almost-win/lose?
      if(i==numGrid-1 && (Xdiag1 == numGrid-1 || Odiag1 == numGrid-1) && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && (Xdiag2 == numGrid-1 || Odiag2 == numGrid-1) && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
          else if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
          else if(board[j][i].innerHTML == currentPlayer.opponent.letter) Overt++;
          
          //Last inner loop. Check for vertical almost-win/lose.
          if(j==numGrid-1 && (Xvert == numGrid-1 || Overt == numGrid-1) && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win/lose.
        if((Xhori == numGrid-1 || Ohori == numGrid-1) && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
      }
    }
    return randomCoord();
  }


  /*
  Similar to notSoRandom, 
  except it prefers filling the last blank to win over preventing its opponent from winning.
  */
  function AI1() 
  {
    var coord = emergency();
    if(coord != false) return coord;
    return randomCoord();
  }

  //Core of AI1.
  function emergency()
  {
    var Xhori=0; var Ohori=0;
    var Xvert=0; var Overt=0;
    var Xdiag1=0; var Odiag1=0;
    var Xdiag2=0; var Odiag2=0;

    //first time looping: win if it can
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Xs and Os
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      else if(board[i][i].innerHTML == currentPlayer.opponent.letter)Odiag1++;
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;

      //Last loop, should've counted all XOdiags. any diagonal almost-win?
      if(i==numGrid-1 && Odiag1 == numGrid-1 && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && Odiag2 == numGrid-1 && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
          else if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
          else if(board[j][i].innerHTML == currentPlayer.opponent.letter) Overt++;
          
          //Last inner loop. Check for vertical almost-win.
          if(j==numGrid-1 && Overt == numGrid-1 && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win.
        if(Ohori == numGrid-1 && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
      }
    }

    //reset all count variables
    Xhori=0; Ohori=0;
    Xvert=0; Overt=0;
    Xdiag1=0; Odiag1=0;
    Xdiag2=0; Odiag2=0;
    //second time looping- if it's only one step from losing, make sure that doesn't happen.
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal Xs and Os
      if(board[i][i].innerHTML == currentPlayer.letter) Xdiag1++;
      else if(board[i][i].innerHTML == currentPlayer.opponent.letter)Odiag1++;
      if(board[i][numGrid-1-i].innerHTML == currentPlayer.letter) Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == currentPlayer.opponent.letter)Odiag2++;

      //Last loop, should've counted all XOdiags. any diagonal almost-win?
      if(i==numGrid-1 && Xdiag1 == numGrid-1 && AIhelper('diag1') != false) 
        return AIhelper('diag1');
      else if(i==numGrid-1 && Xdiag2 == numGrid-1 && AIhelper('diag2') != false) 
        return AIhelper('diag2');

      //no? check for horizontals and verticals.
      else {
        for (var j=0; j<numGrid; j++) {
          //horizontal
          if(board[i][j].innerHTML == currentPlayer.letter) Xhori++;
          else if(board[i][j].innerHTML == currentPlayer.opponent.letter)Ohori++;
          //vertical
          if(board[j][i].innerHTML == currentPlayer.letter) Xvert++;
          else if(board[j][i].innerHTML == currentPlayer.opponent.letter) Overt++;
          
          //Last inner loop. Check for vertical almost-win.
          if(j==numGrid-1 && Xvert == numGrid-1 && AIhelper('vert',i) != false)
            return AIhelper('vert',i);
        }
        //check for horizontal almost-win.
        if(Xhori == numGrid-1 && AIhelper('hori',i) != false)
          return AIhelper('hori',i);
        //reset horizontal and vertical count variables
        Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
      }
    }
    return false;
  }

  /*
  First detect any emergency (one step from win or lose). If there is one, make that move.
  If no emergency and if there's any move better than pure random, make that move: 
    The spot that is on the largest number of all-blank horizontal/vertical/diagonal lines
    If there're multiple such moves, pick a random one among them.
  */
  function AI2() 
  {
    updateMap();
    var alternate = getAlternateMove();
    var priority = emergency();
    if(priority != false) return priority;
    return alternate;
  }

  
  //Core of AI2
  function getAlternateMove()
  {
    max = 0;
    maxArray = new Array();
    for(var i=0; i<numGrid; i++)
    {
      for(var j=0; j<numGrid; j++)//access each grid
      {
        if(board[i][j].innerHTML == '')//count only blank grids
        {
          if(map[i][j] > max) 
          {
            max = map[i][j];
            maxArray = new Array();
            maxArray[maxArray.length] = new Coordinate(i,j);
          } else if(map[i][j] == max) 
            maxArray[maxArray.length] = new Coordinate(i,j);
        }
      }
    }
    if(maxArray.length == 0) {
      return randomCoord();
      console.log('calling randomCoord from getAlternateMove (shouldn\'t happen)');
    }
    var rand = Math.floor(Math.random()*maxArray.length);
    return maxArray[rand];
  }
  
  function updateMap() {
    for(var i=0; i<numGrid; i++)
    {
      for(var j=0; j<numGrid; j++) map[i][j] = 0;
    }

    for(var i=0; i<numGrid; i++)//each row
    {
      for(var j=0; j<numGrid; j++)//each grid
      {
        if(board[i][j].innerHTML == '')//each blank grid
        {
          var h = 0; var v = 0;
          for(var k=0; k<numGrid; k++)//h and v
          {
            if(board[k][j].innerHTML == '') h++;//each grid that shares i with this blank
            if(board[i][k].innerHTML == '') v++;//each grid that shares j with this blank
          }
          if (h == numGrid) map[i][j]++;
          if (v == numGrid) map[i][j]++;

          var v1 = 0; 
          if(i == j)//on v1
          {
            for (var k=0; k<numGrid; k++)//each grid on v1
            {
              if(board[k][k].innerHTML == '') v1++;
            }
          }
          if(v1 == numGrid) map[i][j]++;

          var v2 = 0;
          if(i == numGrid-j-1)//on v2
          {
            for (var k=0; k<numGrid; k++)//each grid on v2
            {
              if(board[k][numGrid-k-1].innerHTML == '')v2++;
            }
          }
          if(v2 == numGrid) map[i][j]++;
        }
      }
    }
  }

  //If there's an only empty Coordinate in a certain row/column/diagonal, return it.
  function AIhelper(direction, num) {
    if(direction == 'diag1') {
      //top left to bottom right
      for (var i=0; i<numGrid; i++) 
        if(board[i][i].innerHTML == '') return new Coordinate(i,i);
    } else if (direction == 'diag2') {
      //top right to bottom left
      for (var i=0; i<numGrid; i++) 
        if(board[i][numGrid-i-1].innerHTML == '') {
          return new Coordinate(i,numGrid-i-1);}
    } else if (direction == 'hori') {
      //num, ?
      for (var i=0; i<numGrid; i++) 
        if(board[num][i].innerHTML == '') return new Coordinate(num,i);
    } else if (direction == 'vert') {
      //?, num
      for (var i=0; i<numGrid; i++)
        if(board[i][num].innerHTML == '') return new Coordinate(i,num);
    }
    return false;
  }
  
  function Coordinate(r, c) {
    this.r = r;
    this.c = c;
  }

  /*
  Evenly divides #container into numGrid rows and numGrid columns of cells
  And store them into board for later access
  */
	function generateCells()
  {
    var container = document.getElementById('container');
    var proportion = 100/numGrid;//percentage of width or height per cell

    for(var i=0; i<numGrid; i++) {
      //create and add row
      var row = document.createElement('div');
      row.style.height = proportion + '%';
      row.className = 'row';
      container.appendChild(row);
      for(var j=0; j<numGrid; j++) {
        //create and add cell
        var cell = document.createElement('div');
        cell.classList.add('cell');
        if(j == 0) cell.classList.add('left');
        if(j == numGrid-1) cell.classList.add('right');
        if(i == 0) cell.classList.add('top');
        if(i == numGrid-1) cell.classList.add('bottom');
        cell.style.position = 'relative';
        cell.style.float = 'left';
        cell.style.width = proportion + '%';
        row.appendChild(cell);
        //add this cell to board (2D array)
        board[i][j] = cell;
      }
    }
  }

  function placeLetter(element) {
    if(gameOver || element.innerHTML != '') return;
    element.classList.add(currentPlayer.letter);
    element.style.lineHeight = container.clientHeight/numGrid + 'px';
    element.innerHTML = currentPlayer.letter;

    winner = detectWin();
    if(gameOver) {
      //end the game
      console.log('Winner: ' + winner);
      //make grids unclickable. 
      for(var i=0; i<numGrid; i++) {
        for(var j=0; j<numGrid; j++) {
          board[i][j].setAttribute('onClick','');
        }
      }
    } else {
      //change player
      currentPlayer = currentPlayer.opponent;
      currentPlayer.move();
    }
  }

  /*
  return 'X' if X wins, or return 'O' if O wins. 
  return 'draw' if the whole board is filled but nobody wins.
  Otherwise doesn't change or return anything.
  */
  var deadCount = 0;
  function detectWin() 
  {
    console.log('----win detection----');
    deadCount = 0;//if a straight line contains both X and O, it's dead. No possible win there.
    var Xhori = 0; var Ohori = 0;
    var Xvert = 0; var Overt = 0;
    var Xdiag1 = 0; var Odiag1 = 0;
    var Xdiag2 = 0; var Odiag2 = 0;
    for(var i=0; i<numGrid; i++) 
    {
      //count diagonal 1 every loop
      if(board[i][i].innerHTML == 'X') Xdiag1++;
      else if(board[i][i].innerHTML == 'O')Odiag1++;
      //count diagonal 2 every loop
      if(board[i][numGrid-1-i].innerHTML == 'X') Xdiag2++;
      else if(board[i][numGrid-i-1].innerHTML == 'O')Odiag2++;
      if(i == numGrid-1)//last outer loop
      {
        //any diagonal win, after going through this outer loop check?
        if(Xdiag1 == numGrid || Xdiag2 == numGrid) {gameOver = true; return 'X';}
        else if(Odiag1 == numGrid || Odiag2 == numGrid) {gameOver = true; return 'O';}
        //are the two diagonals dead by now?
        if(Xdiag1>0 && Odiag1>0) {deadCount++;console.log('diag1 dead');}
        if(Xdiag2>0 && Odiag2>0) {deadCount++;console.log('diag2 dead');}
      }

      //no? check for horizontal and vertical.
      for (var j=0; j<numGrid; j++) 
      {
        //horizontal
        if(board[i][j].innerHTML == 'X') Xhori++;
        else if(board[i][j].innerHTML == 'O')Ohori++;
        //vertical
        if(board[j][i].innerHTML == 'X') Xvert++;
        else if(board[j][i].innerHTML == 'O')Overt++;
      }
      //any horizantal or vertical win, after running this inner loop?
      if(Xhori == numGrid || Xvert == numGrid) {gameOver = true; return 'X';}
      else if(Ohori == numGrid || Overt == numGrid) {gameOver = true; return 'O';}
      //check horizontal/vertical deads
      if(Xhori>0 && Ohori>0) {deadCount++;console.log('hori '+i+' dead');}
      if(Xvert>0 && Overt>0) {deadCount++;console.log('vert '+i+' dead');}
      //reset horizontal and vertical count variables
      Xhori = 0; Ohori = 0; Xvert = 0; Overt = 0;
    }
    if(deadCount == 2 * numGrid + 2) {gameOver = true; return 'draw';}
  }

</script>
<style>
  *{
    margin:0;
    padding:0;
  }

  div.cell{
    margin:0;
    padding:0;
    height:100%;
    border:1px solid maroon;
  }

  div.left{
    border-left:none;
  }

  div.right{
    border-right:none;
  }

  div.top{
    border-top:none;
  }

  div.bottom{
    border-bottom:none;
  }

  div.cell:hover{
    background-color: #ffffcc;
  }

  .X,.O{
    width:100%;
    height:100%;
    font-size:40px;
    text-align:center;
    vertical-align:middle;
  }

  .X{
    color:#E56720;
  }

  .O{
    color:#328748;
  }
  #container{
    width:300px;
    height:300px;
  }
  #title{
    color:maroon;
    margin:1em;
    text-align:center;
  }

</style>
</head>
<body onload="generateCells(); startGame();">
  <div class="container">
    <h2 id="title">Tic Tac Toe</h2>
    <div id="container" class="container-fluid"></div>
  </div>
</body>
</html>